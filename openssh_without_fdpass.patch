--- openssh-6.8p1.orig/mux.c	2015-03-17 06:49:20.000000000 +0100
+++ openssh-6.8p1/mux.c	2015-04-16 13:12:58.500000000 +0200
@@ -29,6 +29,7 @@
  *   - If we ever support the "signal" channel request, send signals on
  *     sessions in master.
  */
+#define __NO_FDPASS
 
 #include "includes.h"
 
@@ -146,6 +147,7 @@
 #define MUX_C_CLOSE_FWD		0x10000007
 #define MUX_C_NEW_STDIO_FWD	0x10000008
 #define MUX_C_STOP_LISTENING	0x10000009
+#define MUX_C_FDPASS		0x1000000A
 #define MUX_S_OK		0x80000001
 #define MUX_S_PERMISSION_DENIED	0x80000002
 #define MUX_S_FAILURE		0x80000003
@@ -172,6 +174,15 @@
 static int process_mux_stdio_fwd(u_int, Channel *, Buffer *, Buffer *);
 static int process_mux_stop_listening(u_int, Channel *, Buffer *, Buffer *);
 
+#ifdef __NO_FDPASS
+int muxfd[3];
+char *muxpipe[3];
+
+static int mux_client_fdpass(int, int);
+static int process_mux_fdpass(int);
+static int mux_redirect(int, int);
+#endif
+
 static const struct {
 	u_int type;
 	int (*handler)(u_int, Channel *, Buffer *, Buffer *);
@@ -373,7 +384,11 @@
 
 	/* Gather fds from client */
 	for(i = 0; i < 3; i++) {
+#ifdef __NO_FDPASS
+		if ((new_fd[i] = process_mux_fdpass(c->sock)) == -1) {
+#else
 		if ((new_fd[i] = mm_receive_fd(c->sock)) == -1) {
+#endif
 			error("%s: failed to receive fd %d from slave",
 			    __func__, i);
 			for (j = 0; j < i; j++)
@@ -434,6 +449,8 @@
 	/* Try to pick up ttymodes from client before it goes raw */
 	if (cctx->want_tty && tcgetattr(new_fd[0], &cctx->tio) == -1)
 		error("%s: tcgetattr: %s", __func__, strerror(errno));
+	// TODO tcgetattr fails on pipe. We can send attributes
+	// the same way we send the rest information
 
 	/* enable nonblocking unless tty */
 	if (!isatty(new_fd[0]))
@@ -946,7 +963,11 @@
 
 	/* Gather fds from client */
 	for(i = 0; i < 2; i++) {
+#ifdef __NO_FDPASS
+		if ((new_fd[i] = process_mux_fdpass(c->sock)) == -1) {
+#else
 		if ((new_fd[i] = mm_receive_fd(c->sock)) == -1) {
+#endif
 			error("%s: failed to receive fd %d from slave",
 			    __func__, i);
 			for (j = 0; j < i; j++)
@@ -1829,9 +1850,15 @@
 		fatal("%s: write packet: %s", __func__, strerror(errno));
 
 	/* Send the stdio file descriptors */
+#ifdef __NO_FDPASS
+	if (mux_client_fdpass(fd, STDIN_FILENO) == -1 || 
+	    mux_client_fdpass(fd, STDOUT_FILENO) == -1 || 
+	    mux_client_fdpass(fd, STDERR_FILENO) == -1)
+#else
 	if (mm_send_fd(fd, STDIN_FILENO) == -1 ||
 	    mm_send_fd(fd, STDOUT_FILENO) == -1 ||
 	    mm_send_fd(fd, STDERR_FILENO) == -1)
+#endif
 		fatal("%s: send fds failed", __func__);
 
 	debug3("%s: session request sent", __func__);
@@ -1881,6 +1908,45 @@
 	if (tty_flag)
 		enter_raw_mode(options.request_tty == REQUEST_TTY_FORCE);
 
+#ifdef __NO_FDPASS
+	fd_set readset, activeset;
+	int maxfd, res;
+	FD_ZERO(&readset);
+	FD_SET(STDIN_FILENO, &readset);
+	FD_SET(muxfd[STDOUT_FILENO], &readset);
+	FD_SET(muxfd[STDERR_FILENO], &readset);
+	FD_SET(fd, &readset);
+	maxfd = muxfd[STDOUT_FILENO] > muxfd[STDERR_FILENO] ?
+		muxfd[STDOUT_FILENO] : muxfd[STDERR_FILENO] ;
+	maxfd = fd > maxfd ? fd : maxfd;
+	do {
+		activeset = readset;
+		res = select(maxfd+1, &activeset, NULL, NULL, NULL);
+		//debug3("select returned %d\n", res);
+		if (res < 0){
+			perror ("select");
+			break;
+		} else {
+			if (FD_ISSET(STDIN_FILENO, &activeset))
+				mux_redirect(STDIN_FILENO, muxfd[STDIN_FILENO]);
+			if (FD_ISSET(muxfd[STDOUT_FILENO], &activeset))
+				mux_redirect(muxfd[STDOUT_FILENO], STDOUT_FILENO);
+			if (FD_ISSET(muxfd[STDERR_FILENO], &activeset))
+				mux_redirect(muxfd[STDERR_FILENO], STDERR_FILENO);
+			if (FD_ISSET(fd, &activeset))
+				goto cleanup;
+			// TODO handle closed fds?
+		}
+	} while(1);
+cleanup:
+	for(i = 0; i <=2; i++){
+		close(muxfd[i]);
+		if (muxpipe[i] != NULL){
+			unlink(muxpipe[i]);
+			free(muxpipe[i]);
+		}
+	}
+#endif
 	/*
 	 * Stick around until the controlee closes the client_fd.
 	 * Before it does, it is expected to write an exit message.
@@ -1975,8 +2041,13 @@
 		fatal("%s: write packet: %s", __func__, strerror(errno));
 
 	/* Send the stdio file descriptors */
+#ifdef __NO_FDPASS
+	if (mux_client_fdpass(fd, STDIN_FILENO) == -1 || 
+	    mux_client_fdpass(fd, STDOUT_FILENO) == -1)
+#else
 	if (mm_send_fd(fd, STDIN_FILENO) == -1 ||
 	    mm_send_fd(fd, STDOUT_FILENO) == -1)
+#endif
 		fatal("%s: send fds failed", __func__);
 
 	debug3("%s: stdio forward request sent", __func__);
@@ -2185,3 +2256,111 @@
 		fatal("unrecognised muxclient_command %d", muxclient_command);
 	}
 }
+
+#ifdef __NO_FDPASS
+static int
+mux_client_fdpass(int fd, int fdpass)
+{
+	Buffer m;
+	char rbuf[16+1];
+	char *path;
+	char r;
+	int ffd;
+	size_t i;
+
+	debug3("%s: entering", __func__);
+
+	for (i = 0; i < sizeof(rbuf) - 1; i++) {
+		r = arc4random_uniform(26+26+10);
+		rbuf[i] = (r < 26) ? 'a' + r :
+		    (r < 26*2) ? 'A' + r - 26 :
+		    '0' + r - 26 - 26;
+	}
+	rbuf[sizeof(rbuf) - 1] = '\0';
+	if (asprintf(&path, "%s.fdpass.%s", options.control_path, rbuf) < 0){
+		error("%s: asprintf: %s", __func__, strerror(errno));
+		return -1;
+	}
+	if (mkfifo(path, O_RDWR) != 0){
+		free(path);
+		error("%s: mkfifo: %s", __func__, strerror(errno));
+		return -1;
+	}
+	debug3("%s: emulating fdpass through fifo %s", __func__, path);
+	if ((ffd = open(path, O_RDWR)) < 0){
+		free(path);
+		error("%s: open: %s", __func__, strerror(errno));
+		return -1;
+	}
+
+	buffer_init(&m);
+	buffer_put_int(&m, MUX_C_FDPASS);
+	buffer_put_cstring(&m, path);
+	if (mux_client_write_packet(fd, &m) != 0){
+		free(path);
+		buffer_free(&m);
+		error("%s: failed to write packet to mux", __func__);
+		return -1;
+	}
+
+	//printf("muxfd[%d] = %d\n", fdpass, ffd);
+	muxfd[fdpass] = ffd;
+	muxpipe[fdpass] = path;
+
+	buffer_free(&m);
+	return 0;
+}
+
+static int
+process_mux_fdpass(int fd)
+{
+	Buffer m;
+	int fdpass, msg_id;
+	char *path;
+	u_int n;
+
+	buffer_init(&m);
+	if (mux_client_read_packet(fd, &m) != 0) {
+		buffer_free(&m);
+		return 0;
+	}
+
+	msg_id = buffer_get_int(&m);
+	path = buffer_get_cstring(&m, &n);
+	if (msg_id != MUX_C_FDPASS)
+		error("%s: Received wrong message id instead of passed pipe", __func__);
+
+	debug3("%s: received fifo %s to emulate fdpass", __func__, path);
+	if ((fdpass = open(path, O_RDWR)) < 0){
+		error("%s: open: %s", __func__, strerror(errno));
+		return -1;
+	}
+
+	free(path);
+	buffer_free(&m);
+	return fdpass;
+}
+
+static int mux_redirect(int source, int target){
+	static char buffer[SSH_IOBUFSZ+1];
+	int result;
+	do {
+		result = read(source, buffer, SSH_IOBUFSZ);
+	} while (result == -1 && errno == EINTR);
+
+	if (result > 0) {
+		result = write(target, buffer, result);
+		//buffer[result] = 0;
+		//debug3("Redirecting %d -> %d data: %s\n", source, target, buffer);
+		return result; // written
+	} else if (result == 0){
+		//close, FD_CLEAR
+		printf("Closing fd %d", source);
+		close(target);
+		return result; // close
+	} else {
+		printf("Error in recv(): %s\n", strerror(errno));
+		return -1;
+	}
+}
+#endif
